‚Äî PROMPT √Ä COLLER DANS VS CODE (COMPLET) ‚Äî

Tu es un assistant d‚Äôing√©nierie logiciel. Cr√©e un projet complet type ‚ÄúFintech-test‚Äù en Python/Flask, Dockeris√©, avec CI/CD GitHub Actions, blue/green local, scans s√©curit√©, tests unitaires/int√©gration, perf k6 (smoke + load), rollback, docs FR. Le projet doit √™tre reproductible sur Windows (pr√©f√©rer WSL2 pour le runner self-hosted). Respecte scrupuleusement les sp√©cifications ci-dessous.

OBJECTIF GLOBAL

Application Flask simple (banque fictive): routes auth (register/login/logout), dashboard prot√©g√©, transactions placeholder, health.
Bases de donn√©es:
CI/dev: SQLite (en volume).
UAT/Prod (local): PostgreSQL 16 (ports h√¥te 5433 et 5434).
Containerisation: Docker + Docker Compose (stacks CI, UAT, PROD blue/green).
CI: build, tests unitaires/int√©gration, pip-audit, Bandit, Trivy (SARIF), ZAP Baseline (non-bloquant), k6 smoke + k6 load, artefacts.
CD local (runner self-hosted): UAT auto sur push main (MODE=build), Prod sur tag v* avec gate d‚Äôapprobation (MODE=build par d√©faut mais documente MODE=image), blue/green, rollback.
Docs en fran√ßais (CI-PIPELINE.md et CD-PIPELINE.md).
Scripts de d√©ploiement blue/green et d‚Äôattente HTTP.
Qualit√©: .coveragerc, .gitattributes (LF pour .sh), healthchecks robustes.
ARBORESCENCE ATTENDUE

app_bank/
app.py
extensions.py
models.py
routes/
auth.py
transactions.py
health.py
main.py
templates/ (HTML basique)
base.html
login.html
register.html
dashboard.html
transactions.html
transfer.html
trading.html
accounting.html
create_account.html
static/
style.css
css/
dashboard.css
login.css
requirements.txt
Dockerfile
docker/
docker-compose.ci.yml
docker-compose.uat.yml
docker-compose.prod.yml
.env.uat.example
.env.prod.example
zap-baseline.conf
scripts/
wait_for_http.sh
deploy_blue_green_local.sh
k6/
perf-smoke.js
perf-load.js
.github/workflows/
ci.yml
cd-local.yml
docs/
CI-PIPELINE.md
CD-PIPELINE.md
tests/
unit/
test_models.py (ex: hashing mot de passe)
test_health.py (ex: /health 200 et JSON ok)
integration/
test_health_integration.py (GET http://localhost:5000/health)
.coveragerc
.gitattributes
.gitignore (classique Python + env + artefacts)
D√âTAILS APPLI FLASK

app_bank/app.py:
create_app() configure Flask, SECRET_KEY (default dev), SQLALCHEMY_DATABASE_URI via env DATABASE_URL (default sqlite:///./transactions.db), SQLALCHEMY_TRACK_MODIFICATIONS=False.
Initialise db et login_manager (login_view=auth.login).
Enregistre blueprints: auth, transactions, health, main.
D√©marrage: db.create_all() avec retry; si SQLite, activer PRAGMA journal_mode=WAL et busy_timeout; si Postgres, contr√¥ler la largeur de user.password_hash et ‚ÄúALTER COLUMN ‚Ä¶ TYPE VARCHAR(255)‚Äù si < 200; seed des utilisateurs si DB vide: admin, alice, bob, charlie (password123) avec soldes tests.
app.run(host=0.0.0.0, port=5000, debug=False).
app_bank/extensions.py:
from flask_sqlalchemy import SQLAlchemy; db = SQLAlchemy()
from flask_login import LoginManager; login_manager = LoginManager()
app_bank/models.py:
User (id, username unique, password_hash String(255), balance Decimal/Numeric); m√©thodes set_password/check_password (werkzeug.security); repr.
Transaction (id, user_id FK, account_id String, amount Numeric, currency String, type String, created_at DateTime).
routes:
health.py: /health: renvoie JSON {"status": "ok"} 200.
main.py: / (redirect login/dashboard), /dashboard (login_required, affiche infos user).
auth.py:
GET/POST /login: form username/password, login_user, redirige dashboard si ok; sinon flash erreur.
GET /logout: login_required, logout_user puis redirect login.
GET/POST /register: v√©rifie unicit√© username; cr√©e l‚Äôutilisateur balance=0, set_password; commit; flash succ√®s; redirect login.
transactions.py: endpoints placeholders (ex: /transactions liste vide) pour future extension.
templates: HTML minimal Bootstrap-like (base.html avec block content; formulaires login/register; dashboard simple).
requirements.txt: Flask, Flask-SQLAlchemy, Flask-Login, python-dotenv, psycopg2-binary, requests, pytest, pytest-cov, werkzeug, sqlalchemy.
DOCKER

app_bank/Dockerfile:
FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt puis pip install --no-cache-dir -r requirements.txt
COPY . .
ENV FLASK_APP=app.py FLASK_ENV=production DATABASE_URL=sqlite:///./transactions.db
EXPOSE 5000
CMD ["python", "app.py"]
docker/docker-compose.ci.yml:
service bank_api (image: bank-api:ci construit en CI), ports ‚Äú5000:5000‚Äù, volume /data, DATABASE_URL=sqlite:////data/transactions.db, healthcheck HTTP sur /health. Pas de cl√© ‚Äúversion‚Äù.
docker/docker-compose.uat.yml:
db: postgres:16, ports ‚Äú5433:5432‚Äù, healthcheck pg_isready, volume nomm√© uat_pgdata.
api: image 
ùêº
ùëÄ
ùê¥
ùê∫
ùê∏
ùëÅ
ùê¥
ùëÄ
ùê∏
:
IMAGE 
N
‚Äã
 AME:{IMAGE_TAG} et build context ../app_bank; ports ‚Äú5001:5000‚Äù; depends_on db:healthy; FLASK_ENV=production; healthcheck HTTP /health.
docker/docker-compose.prod.yml:
db: postgres:16, ports ‚Äú5434:5432‚Äù, healthcheck, volume prod_pgdata.
api_blue et api_green: m√™mes spec que UAT api; profiles [blue]/[green]; un seul publie ‚Äú5002:5000‚Äù √† la fois; healthcheck HTTP /health.
SCRIPTS (LF via .gitattributes; chmod +x dans workflows)

scripts/wait_for_http.sh:
Boucle sur curl -fsS URL avec timeout/bacoff, √©choue au bout d‚Äôun d√©lai configurable; echo diagnostics.
scripts/deploy_blue_green_local.sh:
Param√®tres: TARGET=uat|prod, MODE=image|build, IMAGE_NAME, IMAGE_TAG, RUN_SMOKE=true|false, PRUNE_UAT=true|false.
UAT:
Si MODE=image, docker login ghcr et docker compose -f docker-compose.uat.yml --profile‚Ä¶ up -d avec variables.
Si MODE=build, compose build puis up -d.
Attendre sant√© via wait_for_http.sh sur http://localhost:5001/health; si √©chec: logs compose, ps, exit 1.
Optionnel: k6 smoke contre http://localhost:5001/health.
PROD (blue/green):
D√©marre la couleur inactive sans publier 5002, attend sant√© interne (localhost:5000/health), bascule port 5002 en arr√™tant l‚Äôancienne couleur et en (re)publiant la nouvelle (utilise --remove-orphans).
V√©rifie sant√© externe http://localhost:5002/health; optionnel: k6 smoke.
Collecte diagnostics sur √©chec (compose ps, logs, etc.).
Nettoyage orphelins via --remove-orphans.
K6

k6/perf-smoke.js:
1 VU / 10s; GET BASE_URL/health; thresholds: http_req_failed < 1%, p95 < 800ms.
k6/perf-load.js:
Parcours: GET /health; POST /register (uniquement √† la 1√®re it√©ration par VU: username=user_${VU}, password=Test123!); POST /login; GET /dashboard; sleep(1).
Stages CI-friendly: jusqu‚Äô√† ~40 VU puis maintien, puis descente.
Thresholds: p95 < 800ms; http_req_failed < 10%; ‚Äúerrors‚Äù (m√©trique m√©tier) < 20%.
Gestion cookies sessions auto; formulaires form-encoded.
Note: L‚Äôappli ajuste SQLite (WAL + busy_timeout) pour √©viter les locks sous charge.
Les ex√©cutions en CI doivent lancer les conteneurs k6 en root (-u 0:0) pour √©crire les summary sur le volume mont√©.
Artefacts: k6-summary.json (smoke), k6-summary-load.json (load).
CI GITHUB ACTIONS (.github/workflows/ci.yml)

Triggers: push, pull_request, workflow_dispatch.
Steps:
checkout
mkdir reports et zap-reports
docker build -t bank-api:ci app_bank
docker compose -f docker-compose.ci.yml up -d
attendre /health (boucle curl ~30s)
setup-python 3.11 (pour pip-audit/bandit)
pip install bandit pip-audit
Unit tests (conteneur python:3.11-slim) avec pytest-cov; artefacts junit-unit.xml, coverage.xml
Integration tests (conteneur python --network host) vers http://localhost:5000; artefact junit-integration.xml
pip-audit sur requirements.txt ‚Üí reports/pip-audit.json (non-bloquant)
bandit -r app_bank ‚Üí reports/bandit.json (non-bloquant)
Trivy scan image bank-api:ci ‚Üí reports/trivy.sarif
ZAP Baseline (owasp/zap2docker-stable) sur http://localhost:5000 (non-bloquant) ‚Üí zap-reports/*
k6 smoke (docker run --rm --network host -u 0:0 -v $workspace/k6:/scripts grafana/k6:0.51.0 run --vus 1 --duration 10s --summary-export=/scripts/k6-summary.json /scripts/perf-smoke.js)
k6 load (toujours ex√©cut√©) ‚Üí /scripts/k6-summary-load.json (BASE_URL=http://localhost:5000)
upload artifacts: test-reports, security-reports, zap-reports, k6-summary, k6-summary-load
publish SARIF to code scanning (non-bloquant)
docker compose down -v
Slack notify on failure (si SLACK_WEBHOOK_URL)
Nettoie ‚Äúversion‚Äù d√©pr√©ci√© dans compose CI.
CD GITHUB ACTIONS (.github/workflows/cd-local.yml)

Runners: self-hosted (pr√©f√©rer WSL2 sur Windows).
Triggers:
push sur main ‚Üí d√©ploiement UAT local auto (MODE=build).
push tags ‚Äòv*‚Äô ‚Üí UAT puis gate d‚Äôapprobation ‚Äúproduction‚Äù puis PROD blue/green (par d√©faut MODE=build; documenter qu‚Äôon peut passer en MODE=image si images publi√©es).
workflow_dispatch: deploy/rollback param√©trables (mode, image_name, image_tag, run_smoke, prune_uat, target, image_tag_previous).
Jobs:
setup-runner-check (docker version + docker compose version).
deploy-uat: checkout; set $GITHUB_ENV selon l‚Äôevent (push vs dispatch); GHCR login uniquement si MODE=image; chmod +x scripts/*.sh; pr√©parer docker/.env.uat (g√©n√©rer SECRET_KEY si absent); script deploy_blue_green_local.sh TARGET=uat MODE=$MODE ‚Ä¶
approval: environment production (gate d‚Äôapprobation).
deploy-prod: m√™me logique; docker/.env.prod; script deploy_blue_green_local.sh TARGET=prod MODE=$MODE ‚Ä¶
rollback (manual): si workflow_dispatch action=rollback et image_tag_previous fourni; pour target uat/prod en MODE=image.
Fichiers docker/.env.uat.example et docker/.env.prod.example: variables POSTGRES_DB, USER, PASSWORD; SECRET_KEY placeholder; DATABASE_URL pour l‚ÄôAPI (postgresql://user:pass@db:5432/bankdb); etc.
DOCUMENTATION

CI-PIPELINE.md (FR):
Vue d‚Äôensemble CI, triggers, √©tapes d√©taill√©es (build/test/scans/ZAP/k6), artefacts, Code scanning, ex√©cution locale, FAQ, prochaines √©volutions.
Section k6:
5.9 smoke (d√©j√†) + 5.9 bis load (parcours d√©taill√©; stages, thresholds; artefact).
Comparaison ‚Äúk6 smoke vs k6 load‚Äù (port√©e, intensit√©, risques, seuils, sorties).
CD-PIPELINE.md (FR):
Runners self-hosted (WSL2 recommand√©), installation, ports requis.
Architecture Compose (UAT 5001/5433, PROD 5002/5434, blue/green).
Triggers CD (push main ‚Üí UAT auto; tags v* ‚Üí Prod avec gate; dispatch manuel).
Modes image vs build, recommandations.
Acc√®s aux applis: UAT http://localhost:5001, PROD http://localhost:5002; sant√© /health; /register, /login, /dashboard; comptes seed admin/alice/bob/charlie password123.
Rollback: action=rollback (image), ou revert Git pour UAT (mode build).
Probl√®mes r√©solus (scripts ex√©cutables, timeouts sant√©, migration password_hash √† 255, orphelins, ‚Äúversion‚Äù d√©pr√©ci√©).
Fichiers utiles.
Ajouter captures facultatives (non requis) et liens internes.
TESTS

tests/unit:
test_health.py sur create_app() ‚Üí client test Flask GET /health == 200 & JSON status ok.
test_models.py: cr√©ation User, set_password/check_password, str(User).
tests/integration:
test_health_integration.py (utilise requests GET http://localhost:5000/health).
Config pytest pour trouver tests.
CONFIG QUALIT√â

.coveragerc avec sections run/source=app_bank, paths (inclure variations /work/app_bank, C:\work\app_bank), report show_missing, html directory reports/htmlcov.
.gitattributes: ‚Äú.sh text eol=lf‚Äù + √©ventuellement ‚Äú.py text eol=lf‚Äù.
BONUS/OPTIONNEL

Slack notifications sur √©chec (secret SLACK_WEBHOOK_URL).
Publier SARIF Trivy dans Security > Code scanning.
Ajouter un README.md sommaire avec ‚Äúhow to run locally‚Äù et ‚Äúports‚Äù.
CRIT√àRES D‚ÄôACCEPTATION

‚Äúdocker compose -f docker-compose.ci.yml up -d‚Äù expose API sur 5000; ‚Äúcurl http://localhost:5000/health‚Äù retourne 200 + {"status":"ok"}.
CI: toutes les √©tapes passent; artefacts pr√©sents (tests, security, zap, k6).
CD:
Push sur main d√©clenche UAT (port 5001).
Tag vX.Y.Z d√©clenche UAT puis gate ‚Äúproduction‚Äù puis PROD (port 5002).
Scripts ex√©cutables; bascule blue/green fonctionnelle.
k6:
Smoke et load produisent k6-summary*.json; load enregistre un user par VU uniquement √† la 1√®re it√©ration.
DB migration:
password_hash VARCHAR(255) garanti en Postgres; pas d‚Äôerreur ‚Äúvalue too long‚Äù.
Docs FR compl√®tes (CI-PIPELINE.md, CD-PIPELINE.md) avec URLs/ports et mode image/build.
LIVRABLES

L‚Äôarborescence compl√®te list√©e plus haut avec le code fonctionnel, workflows CI/CD, scripts, k6, docs, tests, configs.
Commits propres. Si possible, initialiser un repo git (sans push).
CONSEILS EX√âCUTION LOCALE (facultatif)

Windows:
Ex√©cuter Docker Desktop, privil√©gier WSL2 pour le runner self-hosted.
D√©marrage rapide:
docker build -t bank-api:ci app_bank
docker compose -f docker-compose.ci.yml up -d
curl http://localhost:5000/health
IMPORTANT

√âvite de r√©utiliser du code externe sous copyright, √©cris le code de z√©ro.
Respecte les ports: 5000 (CI), 5001 (UAT), 5002 (PROD), 5433 (UAT DB), 5434 (PROD DB).
Sers-toi des healthchecks et des scripts fournis.
Mets k6 en root (-u 0:0) pour √©crire les summaries sur volume.
‚Äî FIN DU PROMPT ‚Äî